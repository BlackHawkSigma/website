---
title: GraphQL Scalar - TODO think of a good name
authors: eddeee888
tags: [graphql, scalars, codegen, node, server, typescript]
date: 2023-01-24
description: TODO think of a >50 character description that describes this article
image: /blog-assets/scalable-apis-with-graphql-server-codegen-preset/cover.png
thumbnail: /blog-assets/scalable-apis-with-graphql-server-codegen-preset/thumbnail.png
---

Scalar is one of the most important GraphQL types. Understanding how scalar type works and using the right tools can help us build robust and extendable schemas. 

In this article, we explore Scalar topics (TODO: add words about these topics):

- What is GraphQL Scalar?
- Create Custom GraphQL Scalar
- GraphQL Scalar Tools

## What is GraphQL Scalar?

GraphQL scalar is a primitive type that represents a value in input or output field's return type. GraphQL comes with a few native scalars: `ID`, `Int`, `Float`, `String`, `Boolean`. However, custom scalars can be declared in schemas to represent more complex data types.

### Scalar Value Coercion

One important concept of scalar is coercion which happens when the scalar is used as either input or output. Coercion is the process of turning the incoming value that could be one or many types, and turning it into one outgoing type.

Let's take `ID` scalar as an example:

- When used as input: a client can send either `string` or `number` value and it will be coerced into `string` before it gets to a resolver on the server.
- When used as output: a server can return `string` or `number` and it will be coerced to `string` just before it gets sent back to the client.

Here's the full list of native scalar input and output TypeScript types:

| Scalar | Client can send | Resolver receives | Resolver can send | Client receives |
| --- | --- | --- | --- | --- |
| ID | `string`  | `string` | `string`   | `string` |
|  | `number` | `string` | `number` | `string` |
| Int | `number` (32-bit signed integer) | `number` | `string`  | `number` (32-bit signed integer) |
|  |  |  | `number` (32-bit signed integer) | `number` (32-bit signed integer) |
|  |  |  | `boolean` | `1` if true, `0` if false |
| Float | `number` (Float or number) | `number` | `string` | `number` |
|  |  |  | `number` | `number` |
|  |  |  | `boolean` | `1` if true, `0` if false |
| String | `string` | `string` | `string` | `string` |
|  |  |  | `boolean` | "true” if true, "false" if false |
|  |  |  | `number` | `string` (numeric value converted into string) |
| Boolean | `boolean` | `boolean` | `boolean` | `boolean` |
|  |  |  | `number` | `false` if incoming value is 0, `true` if incoming value is not 0 |

## Custom GraphQL Scalar

As our schemas evolve, we may need to present more complex data types with custom validation rules. To solve this issue, we can use create custom GraphQL scalars to build more robust and extendable schemas.

There are many examples of popular custom scalars that could be used by a lot of projects:

- `DateTime`
- `BigInt`
- `EmailAddress`

There are 3 steps to create a custom GraphQL Scalar:

### 1. Declare Custom Scalar in Schema

You can declare custom GraphQL Scalars using the `scalar` keyword:

```graphql
# schema.graphql
scalar CustomScalar
```

### 2. Create Custom Scalar Resolver

Now, we can create a resolver for the scalar using `GraphQLScalarType` from the `graphql` package:

```tsx
// resolvers/CustomScalar.ts
import { GraphQLScalarType } from "graphql";

export const CustomScalar = new GraphQLScalarType({
  name: "CustomScalar",
  description: "Custom Scalar description",
  parseValue(inputValue: unknown) {
    // (1) Used for input
  },
  parseLiteral(ast) {
    // (2) Used for input
  },
  serialize(outputValue: unknown) {
    // (3) Used for output
  },
});
```

There are 3 main functions to keep in mind when creating a scalar:

1. `parseValue`: This function is called when the scalar is used as variable in an input. The returned value of this function is passed to resolvers. Below is an operation example that would trigger `parseValue`

```graphql
query Example($var: CustomScalar!) {
  example(arg: $var) # variable is used so `parseValue` is called on the server
}
```

2. `parseLiteral`: This function is called when the scalar is used as literal value in an input. The `ast` parameter contains the GraphQL kind (e.g. int or string) and the value of the input. The returned value of this function is passed to resolvers. Below is an operation example that would trigger `parseLiteral`

```graphql
query Example {
  example(arg: "Test") # literal string is used so `parseLiteral` is called on the server
}
```

3. `serialize`: This function is called on the output returned by resolvers, before the value is sent to the client. Note that since most GraphQL servers send results as JSON over HTTP, the return value of `serialize` function must turn the value into `string`, `number` or `boolean`

TODO: Add the image showing the scalar flow related to request  here

### 3. Add Custom Scalar to Resolvers Map

Finally, we can add the custom scalar resolver to the resolvers map. Here's an example of how to do it with [GraphQL Yoga](https://the-guild.dev/graphql/yoga-server):

```tsx
import { createYoga, createSchema } from "graphql-yoga";
import { createServer } from "http";
import { CustomScalar } from "./resolvers/CustomScalar.ts";

const yoga = createYoga({
  schema: createSchema({ 
    typeDefs: /* Your GraphQL typeDefs */, 
    resolvers: {
      CustomScalar
    }
  }),
});
const server = createServer(yoga);
server.listen(4000, () => {
  console.info('Server is running on http://localhost:4000/graphql')
});
```

## GraphQL Scalar Tools

There are lots of tools in the GraphQL ecosystem to support working with both native and custom scalars:

### 1. GraphQL Code Generator

[GraphQL Code Generator](https://the-guild.dev/graphql/codegen) is a CLI tool with an extensive plugin ecosystem to make implementing both GraphQL client and server easier and safer.

For scalars, GraphQL Code Generator can generate input and output types correctly. On top of that, we can customise the types for both native and custom types to fit our needs. 

### Codegen Config for Clients

Here's an example config that generates native scalar types and `CustomScalar` scalar for clients:

```tsx
import type { CodegenConfig } from '@graphql-codegen/cli';

const config: CodegenConfig = {
  schema: '**/schema.graphql',
  generates: {
    'src/schema/types.generated.ts': {
      plugins: ['typescript'],
      scalars: {
        CustomScalar: {
          input: 'string', // this means our server can take CustomScalar as string
          output: 'number', // this means our server will return CustomScalar as number
        }
      }
    }
  }
};

export default config;
```

Running codegen generates template with the following Scalar types:

```tsx
export type Scalars = {
  ID: { input: string | number; output: string };
  String: { input: string; output: string };
  Boolean: { input: boolean; output: boolean };
  Int: { input: number; output: number };
  Float: { input: number; output: number };
  CustomScalar: { input: string; output: number };
};
```

A few things to note here:

- The client can send `string` or `number` for ID scalar as input.
- The client will receive `string` for ID scalar as output.
- `CustomScalar` uses the input and output type that we set in the codegen config

TODO: make a callout about the recent scalar type change

### Codegen Config for Servers

For the server, we can use [typescript-resolvers](https://the-guild.dev/graphql/codegen/plugins/typescript/typescript-resolvers) plugin with the same `scalars` config. This combination changes how scalar types are used: 

- the input is the type of coerced value that resolvers receive *after* `parseValue` or `parseLiteral` functions are called.
- the output is the type that resolvers return *before* `serialize` is called.

Here's the example config for scalars:

```tsx
import type { CodegenConfig } from '@graphql-codegen/cli';

const config: CodegenConfig = {
  schema: '**/schema.graphql',
  generates: {
    'src/schema/types.generated.ts': {
      plugins: ['typescript', 'typescript-resolvers'],
      scalars: {
        ID: {
          input: 'string',
					output: 'string | number',
        },
        CustomScalar: {
          input: 'number',
          output: 'string',
        }
      }
    }
  }
};

export default config;
```

Running codegen generates template with the following Scalar types:

```tsx
export type Scalars = {
  ID: { input: string ; output: string | number };
  String: { input: string; output: string };
  Boolean: { input: boolean; output: boolean };
  Int: { input: number; output: number };
  Float: { input: number; output: number };
  CustomScalar: { input: number; output: string };
};
```

Notes:

- The server's input ID scalar type is *not* what the client sends. Rather, it is the coerced input value the resolvers receive.
- The server's output ID scalar is *not* what the client receives. Rather, it is the value that resolvers can return before it is serialised and sent to the client.

TODO: Make a callout about this being suggested type e.g. Int's output is technically `string | number | boolean`


### 2. graphql-scalars

[graphql-scalars](https://the-guild.dev/graphql/scalars) is a library of many commonly used custom GraphQL Scalars such as `DateTime`, `BigInt`, etc. Even if it is not too hard to create custom scalars, testing and publishing scalars to share between GraphQL servers can quickly distract from delivering customer values. Therefore, it is usually better to use a well-maintained and documented library like `graphql-scalars`.

Here's how we can use `DateTime` scalar from `graphql-scalars`:

1. Declare `DateTime` in the schema:

```graphql
scalar DateTime
```

2. Import `DateTime` resolver into resolvers map:

```tsx
import { createYoga, createSchema } from "graphql-yoga";
import { createServer } from "http";
import { DateTimeResolver } from "graphql-scalars"; // 1. Import resolver

const yoga = createYoga({
  schema: createSchema({ 
    typeDefs: /* Your GraphQL typeDefs */, 
    resolvers: {
      DateTime: DateTimeResolver // 2. Put resolver to resolvers map
    }
  }),
});
const server = createServer(yoga);
server.listen(4000, () => {
  console.info('Server is running on http://localhost:4000/graphql')
});

```

3. Use GraphQL Code Generator to create types:

TODO: check how to use codegen extension type...

```tsx
import type { CodegenConfig } from '@graphql-codegen/cli';

const config: CodegenConfig = {
  schema: '**/schema.graphql',
  generates: {
    'src/schema/types.generated.ts': {
      plugins: ['typescript', 'typescript-resolvers'],
      scalars: {
        ID: {
          input: 'string',
					output: 'string | number',
        },
        DateTime: ''
      }
    }
  }
};

export default config;
```

### 3. Server Preset

TODO: Write words

## Summary

TODO: summarise the thing. 